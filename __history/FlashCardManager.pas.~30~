unit FlashCardManager;

interface

uses
  SysUtils, Classes, Contnrs,
  Generics.Collections,
  IOUtils, Dialogs;

type
  TFlashCard = class
  public
    Definition: string;
    Explanation: string;
    constructor Create(ADef: string = ''; AExp: string = '');
  end;

  TFlashCardGroup = class
  public
    subjectName : string;
    Cards : TObjectList<TFlashCard>;
    constructor Create(name : string);
    destructor Destroy; override; // Added destructor for safety
  end;

  TFlashCardManager = class
  public
    // Subject maps string (SubjectName) to a list of cards for that subject
    Subject: TObjectList<TFlashCardGroup>;

  private // Made private as it's an internal process
    function InternalLoad: boolean;
    function GetFile: boolean;

  public
    constructor Create();
    destructor Destroy; override;

    function CardGroupExists(name : string) : boolean;
    function AddCard(Group, Definition, Explaination : string): boolean;
    function CreateCard(Definition, Explanation: string): TFlashCard;
    function CreateGroup(name : string): boolean;
    function RemoveCard(name : string): boolean;
    function RemoveGroup(group , name : string): boolean;
    function GetGroup(groupName : string): TFlashCardGroup;
    function GetCard(definition : string): boolean; // Unused but kept
    function Load: boolean;
    function Save: boolean;
  end;

var
  UserCards: TextFile;
  Manager: TFlashCardManager;

implementation

uses LoginManager; // Required for 'user' variable

{ TFlashCard }

constructor TFlashCard.Create(ADef: string; AExp: string);
begin
  inherited Create;
  Definition := ADef;
  Explanation := AExp;
end;

{ TFlashCardGroup}

constructor TFlashCardGroup.Create(name : string);
begin
  inherited Create;
  // CRITICAL FIX: Use Create(True) so the TObjectList frees the TFlashCard objects.
  Cards := TObjectList<TFlashCard>.Create(True);
  subjectName := name;
end;

destructor TFlashCardGroup.Destroy;
begin
  // TObjectList<TFlashCard>.Create(True) handles the freeing of TFlashCard objects.
  Cards.Free;
  inherited;
end;

{ TFlashCardManager }

constructor TFlashCardManager.Create();
begin
  // TObjectList<TFlashCardGroup>.Create(True) automatically frees TFlashCardGroup objects.
  Subject := TObjectList<TFlashCardGroup>.Create(True);
end;

destructor TFlashCardManager.Destroy;
begin
  Save; // Trigger save on shutdown
  // Subject.Free is implicitly handled by the inherited Free;
  // No need for Subject.Clear or Subject.Free if the list owns the objects.
  inherited;
end;

function TFlashCardManager.GetFile(): boolean;
var
  FileName: string;
begin
  // Use a clear file naming convention
  FileName := user.StudentID + '.cards.txt';

  Result := False;
  if TFile.Exists(FileName) then
  begin
    AssignFile(UserCards, FileName);
    Result := True;
  end;
end;

function TFlashCardManager.CreateCard(Definition, Explanation: string): TFlashCard;
begin
  Result := TFlashCard.Create(Definition, Explanation);
end;

function TFlashCardManager.Load(): boolean;
begin
  Result := False;

  // Ensure the file exists before attempting to open it
  if not GetFile then Exit;

  try
    Reset(UserCards); // Open the file for reading
    Result := InternalLoad;
  except
    on E: Exception do
    begin
      ShowMessage('Error opening or reading file: ' + E.Message);
      Result := False;
    end;
  end;

  CloseFile(UserCards);
end;

// CRITICALLY CORRECTED IMPLEMENTATION
function TFlashCardManager.InternalLoad: boolean;
var
  CurrentLn, SubjectName, TempValue: string;
  Card: TFlashCard;
  group: TFlashCardGroup;
  List: TFlashCardGroup;
begin
  Result := False;

  // Clear existing data first and ensure the lists within groups are freed
  Subject.Clear; // TObjectList<TFlashCardGroup>.Create(True) handles the freeing of groups

  Card := nil; // Initialize the card pointer

  try
    while not Eof(UserCards) do
    begin
      ReadLn(UserCards, CurrentLn);
      CurrentLn := Trim(CurrentLn);

      // 1. Check for the start of a new subject block
      if Pos('SUBJECT :', CurrentLn) = 1 then
      begin
        SubjectName := Trim(Copy(CurrentLn, Length('SUBJECT :') + 1, MaxInt));

        // Find existing group or create a new one
        group := GetGroup(SubjectName);
        if group = nil then
        begin
          group := TFlashCardGroup.Create(SubjectName); // ✅ CORRECTED: Create instance
          Subject.Add(group);
        end;

        Card := nil; // Reset card pointer for the next card sequence

      end
      // 2. Handle card field data - Start of a new card block
      else if Pos('DEFINITION :', CurrentLn) = 1 then
      begin
        // Free previous card if CLOSECARD was missed or for any reason
        if Assigned(Card) then FreeAndNil(Card);

        Card := TFlashCard.Create; // ✅ CORRECTED: Create new card for definition

        TempValue := Trim(Copy(CurrentLn, Length('DEFINITION :') + 1, MaxInt));
        Card.Definition := TempValue;

      end
      else if Pos('EXPLANATION :', CurrentLn) = 1 then
      begin
        if Assigned(Card) then
        begin
          TempValue := Trim(Copy(CurrentLn, Length('EXPLANATION :') + 1, MaxInt));
          Card.Explanation := TempValue;
        end;
      end
      // 3. Handle card block closing
      else if CurrentLn = 'CLOSECARD' then
      begin
        if Assigned(Card) and Assigned(group) then
        begin
          // Add the fully read card to the current group
          group.cards.Add(Card);
          Card := nil; // Clear pointer for the next card
        end;
      end;

    end; // End of outer while loop (EOF)
    Result := True;
  except
    on E: Exception do
    begin
      if Assigned(Card) then FreeAndNil(Card);
      ShowMessage('Error during internal load process: ' + E.Message);
      Result := False;
    end;
  end;
end;


// CORRECTED SAVE IMPLEMENTATION
function TFlashCardManager.Save(): boolean;
var
  I, X: integer;
  group: TFlashCardGroup;
  card: TFlashCard;
  FileName: string;
begin
  Result := False;
  if not Assigned(user) then Exit;

  // 1. Assign the file name based on the user
  FileName := user.StudentID + '.cards.txt';
  AssignFile(UserCards, FileName);

  // 2. Open the file for writing (erasing previous content) ONCE
  try
    Rewrite(UserCards);

    // 3. Loop through all subject groups
    for I := 0 to Subject.Count - 1 do
    begin
      group := Subject[I];

      // Write Subject Header
      WriteLn(UserCards, 'SUBJECT :' + group.subjectName);

      // 4. Loop through all cards in the current subject group
      for X := 0 to group.cards.Count - 1 do
      begin
        card := group.Cards[X];
        WriteLn(UserCards, 'DEFINITION :' + card.Definition);
        WriteLn(UserCards, 'EXPLANATION :' + card.Explanation);
        WriteLn(UserCards, 'CLOSECARD');
      end;
    end;

    Result := True;
  except
    on E: Exception do
    begin
      ShowMessage('Error saving flashcard data: ' + E.Message);
      Result := False;
    end;
  end;

  // 5. CRITICAL: Close the file stream after all writing is complete
  CloseFile(UserCards);
end;

// CORRECTED GetGroup implementation
function TFlashCardManager.GetGroup(groupName : string): TFlashCardGroup;
var
  i : integer;
begin
  Result := nil;
  for I := 0 to Subject.Count - 1 do
  begin
    if Subject[i].subjectName = groupName then
    begin
      Result := Subject[i];
      Exit;
    end;
  end;
end;

function TFlashCardManager.CardGroupExists(name : string) : boolean;
begin
  Result := GetGroup(name) <> nil;
end;

function TFlashCardManager.RemoveCard(group , name : string);
var
I : Integer;
begin
  for I := 0 to Subject.Count - 1 do
  begin
    if subject[i].name = group then

  end;
end;

function TFlashCardManager.RemoveGroup(name: string);
begin

end;

function TFlashCardManager.AddCard;
var
  groupObj: TFlashCardGroup;
begin
  Result := False;

  // Find the group to add the card to
  groupObj := GetGroup(Group);

  if Assigned(groupObj) then
  begin
    // Create the card object and add it to the group's list
    groupObj.Cards.Add(CreateCard(Definition, Explaination));
    Result := True;
  end
  else
  begin
    ShowMessage('Failed to add card: Subject group "' + Group + '" not found.');
  end;
end;

function TFlashCardManager.CreateGroup(name : string) : boolean;
var
  tmp : TFlashCardGroup;
begin
  Result := False;
  if CardGroupExists(name) then
  begin
    ShowMessage('Failed: Group Already Exists');
    Exit;
  end;

  // Create and add the new group
  tmp := TFlashCardGroup.Create(name);
  Subject.Add(tmp);
  ShowMessage('Successfully: Group Created');
  Result := true;
end;

function TFlashCardManager.GetCard(definition : string): boolean;
begin
  // This function is still empty in your source, leaving as placeholder
  Result := False;
end;

// Global instance creation
initialization
  Manager := TFlashCardManager.Create;
  manager.Subject := TObjectList<TFlashCardGroup>.Create;

finalization
  FreeAndNil(Manager);

end.
